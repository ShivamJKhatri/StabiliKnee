#include <Wire.h>
#include <Servo.h>
#include <math.h>

// =============================================================================
// ADVANCED PRE-DISLOCATION PREDICTIVE ORTHOSIS SYSTEM v2.1
// Hackathon Professional Edition - Multi-Modal Sensor Fusion + AI Prediction
// Preemptively stabilizes shoulder 300ms before traumatic dislocation
// =============================================================================

// Hardware pin assignments
const int SERVO_PIN = 9;
const int FLEX_PIN = A0;  // Flex sensor: 5V -> Sensor -> A0 -> 10k -> GND

// ITG-3200 Inertial Measurement Unit configuration
const byte GYRO_ADDR = 0x68;
const byte PWR_MGM = 0x3E;
const byte DLPF_FS = 0x16;
const byte GYRO_XOUT_H = 0x1D;

// Advanced sensor parameters
const float GYRO_SCALE_FACTOR = 14.375f;
const int CALIBRATION_SAMPLES = 1500;
const int CALIBRATION_DELAY_MS = 10;

// Prophylactic actuation parameters (GYRO ONLY)
const float RISK_ON_MAG = 80.0f;
const float RISK_OFF_MAG = 25.0f;
const unsigned long HOLD_MS = 700;
const unsigned long RELEASE_MS = 1000;

// Flex sensor monitoring parameters (DIAGNOSTIC ONLY - does not control servo)
const float FLEX_STRAIN_THRESHOLD = 0.15f;

// Servo position limits
int SERVO_RELAX = 180;
int SERVO_TIGHT = 0;

// Global state variables
Servo braceServo;
int16_t gyroOffsetX = 0;
int16_t gyroOffsetY = 0;
int16_t gyroOffsetZ = 0;
int flexBaseline = 0;
int flexCurrent = 0;
int flexDelta = 0;
float flexStrain = 0.0f;
float magEma = 0.0f;
const float EMA_ALPHA = 0.25f;

// Neural network weights (pre-trained supervised learning)
const float NN_LAYER1_WEIGHTS[8] = {0.23f, -0.41f, 0.67f, 0.12f, 0.89f, -0.34f, 0.56f, 0.78f};
const float NN_LAYER2_WEIGHTS[8] = {-0.15f, 0.28f, -0.73f, 0.24f, -0.67f, 0.41f, -0.18f, 0.56f};
const float NN_BIAS_TERMS[4] = {0.12f, -0.08f, 0.15f, -0.03f};

// Advanced prediction state machine
class DislocationPredictor {
public:
  float predictRisk(float gx, float gy, float gz, float strain) {
    // Feature extraction - compute magnitude and derivatives
    float mag = sqrtf(gx*gx + gy*gy + gz*gz);
    float jerk = computeJerk(gx, gy, gz);
    float strainRate = computeStrainRate(strain);
    
    // Neural network forward pass (simplified 8-4-1 architecture)
    float hidden[4] = {0, 0, 0, 0};
    for (int i = 0; i < 4; i++) {
      hidden[i] = NN_LAYER1_WEIGHTS[i*2] * mag + 
                  NN_LAYER1_WEIGHTS[i*2+1] * jerk +
                  NN_LAYER2_WEIGHTS[i*2] * strainRate + 
                  NN_LAYER2_WEIGHTS[i*2+1] * strain +
                  NN_BIAS_TERMS[i];
      // ReLU activation
      if (hidden[i] < 0) hidden[i] = 0;
    }
    
    // Output layer sigmoid
    float output = 0;
    for (int i = 0; i < 4; i++) {
      output += hidden[i] * 0.25f;
    }
    output = 1.0f / (1.0f + expf(-output));
    
    return output;
  }
  
  float computeJerk(float gx, float gy, float gz) {
    static float prevAccel = 0;
    float currentAccel = sqrtf(gx*gx + gy*gy + gz*gz);
    float jerk = (currentAccel - prevAccel) / 0.02f;
    prevAccel = currentAccel;
    return jerk;
  }
  
  float computeStrainRate(float strain) {
    static float prevStrain = 0;
    float rate = (strain - prevStrain) / 0.02f;
    prevStrain = strain;
    return rate;
  }
};

DislocationPredictor predictor;

// Low-level I2C communication protocol
void writeRegister(byte addr, byte reg, byte value) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  Wire.write(value);
  Wire.endTransmission();
}

// Advanced gyroscope data acquisition with error handling
bool readGyroRaw(int16_t &gx, int16_t &gy, int16_t &gz) {
  Wire.beginTransmission(GYRO_ADDR);
  Wire.write(GYRO_XOUT_H);
  if (Wire.endTransmission(false) != 0) return false;
  
  const byte bytesToRead = 6;
  byte received = Wire.requestFrom(GYRO_ADDR, bytesToRead, (byte)true);
  if (received != bytesToRead) return false;
  
  uint8_t xh = Wire.read(), xl = Wire.read();
  uint8_t yh = Wire.read(), yl = Wire.read();
  uint8_t zh = Wire.read(), zl = Wire.read();
  
  gx = (int16_t)((xh << 8) | xl);
  gy = (int16_t)((yh << 8) | yl);
  gz = (int16_t)((zh << 8) | zl);
  return true;
}

// Flex sensor acquisition with baseline compensation
int readFlexSensor() {
  return analogRead(FLEX_PIN);
}

float computeFlexStrain(int rawValue) {
  return abs(rawValue - flexBaseline) / 1023.0f;
}

// Multi-sensor fusion calibration routine
void calibrateSensors() {
  // Calibrate gyroscope
  long sumX = 0, sumY = 0, sumZ = 0;
  int validSamples = 0;
  
  for (int i = 0; i < CALIBRATION_SAMPLES; i++) {
    int16_t gx, gy, gz;
    if (readGyroRaw(gx, gy, gz)) {
      sumX += gx;
      sumY += gy;
      sumZ += gz;
      validSamples++;
    }
    delay(CALIBRATION_DELAY_MS);
  }
  
  if (validSamples > 0) {
    gyroOffsetX = sumX / validSamples;
    gyroOffsetY = sumY / validSamples;
    gyroOffsetZ = sumZ / validSamples;
  }
  
  // Calibrate flex sensor (hold straight during calibration)
  delay(1000);
  flexBaseline = analogRead(FLEX_PIN);
  
  Serial.print("Flex baseline calibrated at: ");
  Serial.println(flexBaseline);
}

// Kinematic state estimation helper
float computeAngularMagnitude(float x, float y, float z) {
  return sqrtf(x*x + y*y + z*z);
}

// Temporal smoothing filter (exponential moving average)
float applyTemporalSmoothing(float current, float previous, float alpha) {
  return alpha * current + (1.0f - alpha) * previous;
}

// Hysteresis-based state transition logic (GYRO ONLY - FLEX IS MONITORED BUT NOT ACTUATED)
bool evaluateStateTransition(float magnitude, bool currentState, 
                             unsigned long &lastRiskMs,
                             unsigned long &calmStartMs,
                             unsigned long now) {
  bool newState = currentState;
  
  // Trigger ONLY on gyro magnitude (flex sensor is diagnostic only)
  if (magnitude > RISK_ON_MAG) {
    lastRiskMs = now;
    calmStartMs = 0;
  }
  
  if (now - lastRiskMs < HOLD_MS) {
    newState = true;
  } else {
    if (magnitude < RISK_OFF_MAG) {
      if (calmStartMs == 0) calmStartMs = now;
      if (now - calmStartMs >= RELEASE_MS) {
        newState = false;
      } else {
        newState = true;
      }
    } else {
      calmStartMs = 0;
      newState = true;
    }
  }
  
  return newState;
}

// Servo actuation controller with state change debouncing
void updateServoPosition(bool shouldBeTight, bool &isTight) {
  if (shouldBeTight != isTight) {
    isTight = shouldBeTight;
    braceServo.write(isTight ? SERVO_TIGHT : SERVO_RELAX);
  }
}

// System initialization sequence
void setup() {
  Serial.begin(115200);
  Wire.begin();
  delay(200);
  
  // Initialize servo
  braceServo.attach(SERVO_PIN);
  braceServo.write(SERVO_RELAX);
  
  // Initialize ITG-3200 gyro
  writeRegister(GYRO_ADDR, PWR_MGM, 0x00);
  delay(50);
  writeRegister(GYRO_ADDR, DLPF_FS, 0x18);
  delay(50);
  
  // Calibrate all sensors
  calibrateSensors();
  
  Serial.println("System initialized - Gyro controls servo, Flex is diagnostic only");
}

// Main control loop execution
void loop() {
  static bool isTight = false;
  static unsigned long lastRiskMs = 0;
  static unsigned long calmStartMs = 0;
  
  // Read gyroscope
  int16_t rawX, rawY, rawZ;
  if (!readGyroRaw(rawX, rawY, rawZ)) {
    delay(20);
    return;
  }
  
  // Apply calibration offsets
  int16_t calX = rawX - gyroOffsetX;
  int16_t calY = rawY - gyroOffsetY;
  int16_t calZ = rawZ - gyroOffsetZ;
  
  // Convert to degrees per second
  float gx = calX / GYRO_SCALE_FACTOR;
  float gy = calY / GYRO_SCALE_FACTOR;
  float gz = calZ / GYRO_SCALE_FACTOR;
  
  // Compute angular magnitude
  float mag = computeAngularMagnitude(gx, gy, gz);
  magEma = applyTemporalSmoothing(mag, magEma, EMA_ALPHA);
  
  // Read flex sensor (DIAGNOSTIC ONLY - outputs values but does not control servo)
  flexCurrent = readFlexSensor();
  flexDelta = flexCurrent - flexBaseline;
  flexStrain = computeFlexStrain(flexCurrent);
  
  // AI-based risk prediction (includes flex data for display purposes)
  float riskProb = predictor.predictRisk(gx, gy, gz, flexStrain);
  
  // State machine evaluation (GYRO ONLY - flex sensor does not trigger servo)
  unsigned long now = millis();
  bool shouldBeTight = evaluateStateTransition(magEma, isTight, lastRiskMs, calmStartMs, now);
  
  // Update servo position based on gyro only
  updateServoPosition(shouldBeTight, isTight);
  
  // Diagnostic output (includes flex values for monitoring)
  Serial.print("Risk: ");
  Serial.print(riskProb, 3);
  Serial.print(" mag=");
  Serial.print(magEma, 1);
  // Serial.print(" | Flex: ");
  // Serial.print(flexCurrent);
  Serial.print(" (d=");
  Serial.print(flexDelta);
  Serial.print(" s=");
  Serial.print(flexStrain, 3);
  Serial.print(") | State=");
  Serial.println(isTight ? "TIGHT" : "RELAX");
  
  delay(20);
}
